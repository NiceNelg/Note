# 基础语法

---

### 寄存器

- 通用寄存器

  | 寄存器     |      |      |      |       |       | 编号(二进制) | 编号(十进制) |
  | ---------- | ---- | ---- | ---- | ----- | ----- | ------------ | ------------ |
  |            | 64位 | 32位 | 16位 | 高8位 | 低8位 |              |              |
  | 累加寄存器 | RAX  | EAX  | AX   | AH    | AL    | 000          | 0            |
  | 计数寄存器 | RCX  | ECX  | CX   | CH    | CL    | 001          | 1            |
  | 数据寄存器 | RDX  | EDX  | DX   | DH    | DL    | 010          | 2            |
  | 基址寄存器 | RBX  | EBX  | BX   | BH    | BL    | 011          | 3            |
  | 堆栈顶指针 | RSP  | ESP  | SP   | x     | x     | 100          | 4            |
  | 堆栈基指针 | RBP  | EBP  | BP   | x     | x     | 101          | 5            |
  | 变址寄存器 | RSI  | ESI  | SI   | x     | x     | 110          | 6            |
  | 指令寄存器 | RDI  | EDI  | DI   | x     | x     | 111          | 7            |

### 指令语句

- `mov`

  1. 解析：

     赋值指令，格式：`mov? 值, 目标位置`

  2. 例子：

     | mov? | bits | example           |
     | ---- | ---- | ----------------- |
     | b    | 8    | `movb %al, %bl`   |
     | w    | 16   | `movw %ax, %bx`   |
     | l    | 32   | `movl %eax, %ebx` |
     | q    | 64   | `movq %rax, %rbx` |

     > 当指令中含有寄存器时，`mov?`中的`?`可不写，如：`mov $0xFF00EE88 %eax`

- `$`

  1. 解析：

     1. 立即数的标识，格式：`$立即数`
     2. 取内存地址，格式：`$内存变量名`

  2. 例子：

     |             | value | immediate |
     | ----------- | ----- | --------- |
     | decimal     | 125   | $125      |
     | hexadecimal | f8    | $0xf8     |
     | octal       | 17    | $017      |
     | binary      | 1001  | $0b1001   |

### 内存操作

```assembly
.seciton .data
values:
	.int 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60
```

- 间接寻址操作：

  | instruction          | action                                                       | result                 |
  | -------------------- | ------------------------------------------------------------ | ---------------------- |
  | `movl values, %eax`  | 将`values`的第一个整型移到`eax`寄存器                        | `eax=10`               |
  | `movl $values, %edi` | 将`values`的地址移到`edi`寄存器，相当于C语言里的`&p`操作     | `edi=values的起始地址` |
  | `movl %ebx, (%edi)`  | 将`ebx`寄存器的值赋值给`edi`指向的内存地址，相当于C语言中的`*p=a` | `10`替换成`ebx`的值    |
  | `movl $99, 4(%edi)`  | 将立即数`99`赋值给`edi`指向的内存地址再偏移4个byte的内存地址，数字4可为负数 | `15`替换成`99`         |

- 直接寻址：

  格式：`base_address(offset_address, index, size)`

  解析：`memory_address = base_address + offset_address + index * size` 

  ```assembly
  movl $2, %edi
  movl values(, %edi, 4), %eax
  ```

  结果：`eax = 20`

  注意：

  - `offset_address`必须为寄存器
  - `index`必须为寄存器
  - `size`可以为数字
  - 等于`0`的位置可以省略不写