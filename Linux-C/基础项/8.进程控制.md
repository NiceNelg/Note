# 进程控制

---

### 创建子进程

​	在代码中一般使用`fork`函数创建子进程，以下是`fork`函数的一些解释和特点：

3. 调用`fork`函数时，内核会根据父进程复制出一个子进程，父进程和子进程的PCB信息相同，用户态代码和数据也相同。因此，子进程的初始状态和父进程一样。
2. `fork`函数的特点是“调用一次，返回两次”，在父进程中调用一次，在父进程和子进程中各返回一次。
3. `fork`函数在子进程中返回0，子进程仍可以调用`getpid`函数得到自己的进程id，也可以调用`getppid`函数得到父进程的id。在父进程中用`getpid`可以得到自己的进程id，然而要想得到子进程的id，只有将`fork`的返回值记录下来，或者等子进程结束回收子进程资源的时候才能得知。
4. `fork`函数的另一个特性是所有由父进程打开的描述符都被复制到子进程中。父、子进程中相同编号的文件描述符在内核中指向同一个FILE结构体，也就是说，FILE结构体的引用计数要增加。
5. 在父进程调用`fork`函数之前，若存在全局变量，那么在后续的代码中如果父子进程均没有修改该全局变量，那么父子进程中该全局变量的物理内存地址指向的是同一个地址；若父/子进程修改了该全局变量，那么内核会在修改时复制一个变量，同时父/子进程中的该全局变量也会指向刚刚复制出来的变量的物理内存地址。这是操作系统为了节省内存的机制。因此父子进程的数据不共享。

### 孤儿进程与僵尸进程

- 孤儿进程

  孤儿进程指的是子进程被创建出来后，父进程退出了，但子进程仍在运行。这时候子进程因父进程退出了成了孤儿进程，孤儿进程会统一被`init`进程接管，`init`进程也会称为孤儿进程的父进程。同时操作系统会有`/sbin/init`、`init --user`两个`init`进程，具体会归属到哪个`init`进程由操作系统的调度决定。

- 僵尸进程

  僵尸进程指的是子进程运行结束后父进程一直运行但是并不去回收子进程的`pcb`因此子进程的`pcb`一直残存在内核中。僵尸进程不能被杀死结束，因为它已经结束运行了，只是有信息残存在内核中。残存的信息会随父进程结束时被一并清除。

### 回收子进程

- `wait`函数
  1. `wait`函数用于回收子进程的资源，同时会返回子进程结束的原因和结束的子进程id。
  2. `wait`函数默认会阻塞等待子进程结束。
  3. 执行一次`wait`函数只会回收一个子进程。
  4. 若多次调用`wait`超过可回收的子进程数`wait`函数也会立即返回并返回错误，可用此方式用循环回收所有子进程而不需要记录子进程个数。