# C指针注意项

---

1. 当定义指针时，如：

   ```c
   int *p;
   ```

   应看作(int *)p;

   因此当定义指针变量同时又赋值时应赋值地址，如：

   ```c
   int *p = &a;
   ```

   当定义过指针变量时，如果没赋值过地址时，应该先赋值地址

   ```c
   int *p;
   
   p = &a;
   ```

   如此则造成*p赋值和p赋值都是等价的错觉

2. 当有（类型 *）指针的形式时，说明是强制转换而不是指针操作，如：

   ```c
   *((int *)p)	//等价于p只是*p转换成整型指针
   
   *(*p)	//则是二级指针操作
   ```

3. 结构体指针操作

   1. 结构体指针有独立的指针操作符->，使用->操作符时只需要指针的地址，如：

      ```c
      //指针初始化参考第一点，亦可写写成：
      
      //student *p;
      
      //p =  (student *)malloc(sizeof(student));
      
      student *p = (student *)malloc(sizeof(student));
      
      p->name;
      ```

   2. 结构体操作符(圆点操作符) . 是对结构体变量的操作，如

      ```c
      student *p = (student *)malloc(sizeof(student));
      
      student s;
      
      //s.name等价于p->name
      
      //而且p.name写法是错误的，因为圆点操作符只针对结构体变量，则：
      
      (*p).name = p->name
      
      //而*(p->name)是正确的，说明地址等于p->name变量的值进行操作
      ```

   3. 指针函数和函数指针

      1. 指针函数是值返回值为指针的函数，如：

         ```c
         void *function_a();
         ```

      2. 函数指针指的是函数名为指针的函数，如：

         ```c
         void (*function_b)(int x, int y);
         ```

         > 此类型函数可作注册函数使用，如：

         ```c
         void function_c(int a, int b);
         
         function_b = &function_c;
         
         //则可以这样调用function_c
         
         (*function_b)(x, y);
         
         //如果函数指针已使用typedef声明类型，如：
         
         typedef void (*function_b)(int x, int y);
         
         //则可以这样调用function_c
         
         function_b func
         
         func = &function_c
         
         (*func)(x, y);
         ```

   4. 数组指针和指针数组

      1. 数组指针（也称行指针），指向一个一维数组的指针，如：

         ```c
         /*
          * 定义 int (*p)[n];
          * ()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，
          * 也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。
          * 如要将二维数组赋给一指针，应这样赋值：
         */
         int a[3][4];
         /*该语句是定义一个数组指针，指向含4个元素的一维数组。*/
         int (*p)[4];
         /*将该二维数组的首地址赋给p，也就是a[0]或&a[0][0]*/
         p=a;
         /*该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]*/
         p++;
         
         /*所以数组指针也称指向一维数组的指针，亦称行指针*/
         ```

      2. 指针数组

         ```c
         /*
          * 定义 int *p[n];
          * []优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组，
          * 它有n个指针类型的数组元素。这里执行p+1时，则p指向下一个数组元素，这样赋值是错误的：p=a；
          * 因为p是个不可知的表示，只存在p[0]、p[1]、p[2]...p[n-1],
          * 而且它们分别是指针变量可以用来存放变量地址。但可以这样 p=a; 
          * 这里p表示指针数组第一个元素的值，a的首地址的值。
          */
         
         /*如要将二维数组赋给一指针数组:*/
         int *p[3];
         int a3;
         /*该语句表示p数组指向下一个数组元素。注：此数组每一个元素都是一个指针*/
         p++;
         for(i=0;i<3;i++) {
         	p[i]=a[i];
         }
         
         /* 这里int *p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]
          * 所以要分别赋值。
          * 这样两者的区别就豁然开朗了，数组指针只是一个指针变量，
          * 似乎是C语言里专门用来指向二维数组的，它占有内存中一个指针的存储空间。
          * 指针数组是多个指针变量，以数组形式存在内存当中，占有多个指针的存储空间。
          * 
          * 还需要说明的一点就是，同时用来指向二维数组时，其引用和用数组名引用都是一样的。
          * 比如要表示数组中i行j列一个元素：
          * (p[i]+j)、((p+i)+j)、((p+i))[j]、pi
          * 
          * 优先级：()>[]>*
          */
         ```

   5. `char *`变成常量

      1. `char *p = "Hello";`：指针指向一个常量

         > 上述情况中，指针p指向了一个字符串常量，因此可以使用指针p访问该常量，但不能修改，不过可以更改指针p的指向。

      2. `char p[] = "Hello";`：常量将自身的值赋值给数组

         > 上述情况中，字符串常量将自身的值赋值给数组，数组并不指向常量，因此数组的值可访问、更改。

   6. `const`和`char *`的组合

      1. `const char *p;`

         > `*p`是`const`，`p`可变，`const` 后面紧跟的是`char`，所以`*p`是一个`char`字符，不可变

      2. `const (char *) p;`

         > 如上。

      3. `char * const p;`

         > `p`是`const`，`*p`可变，`const` 后面紧跟的是`p`,所以`p`不可变（指针地址不能修改），`*p`指向的数据可变

      4. `const char* const p;`

         > `p`和`*p`都是`const`，第一个`const`后面紧跟的是`char *`，所以`char`类型的字符`*p`不可变，第二个`const`后面紧跟的是`p`，所以`p`不可变。

      5. `char const * p;`

         > `*p`是`const`，`p`可变，`const`后面紧跟的是`*`,但是单独的`*`不能表明修饰的内容，所以将`*p`看成一个整体，所以`const`修饰的是`*p`，`*p`不可变。

      6. `(char*) const p;`

         > `p`是`const`，`*p`可变，`const`紧跟的是`p`，所以`p`不可变。

      7. `char* const p;`

         > `p`是`const`，`*p`可变，`const`紧跟的是`p`，所以`p`不可变。

      8. `char const* const p;`

         > `p`和`*p`都是`const`，第一个`const`紧跟的是`*`，不能表明修饰的内容，将后面整体的`(* const p)`看成一个整体，那就说明`*p`不可变，第二个`const`后面紧跟的是`p`，所以`p`不可变。
      9. `const char * const p;`

         > 如上。
