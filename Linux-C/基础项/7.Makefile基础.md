# Makefile基础

---

1. 基本格式

   ```makefile
   目标:依赖1 依赖2 依赖3...
   	生成目标的指令1
   	生成目标的指令2
   	...
   
   目标:依赖1 依赖2 依赖3...
   	生成目标的指令
   ```

   > `生成目标的指令`前面严格使用`tab`缩进，生成一个`目标`可以有多条指令，按顺序执行

2. 工作原理：

   `Makefile`是以`目标`为单位执行指令的，主要功能是**以目标的依赖为原材料执行指令生成目标**，因此`目标`和`依赖`的检测条件都默认是目录下的文件（以及文件的修改时间等等）。若`总目标`中的`依赖`在目录中缺失会向下搜索以该`依赖`作为目标的`目标`执行并生成`依赖`，默认`总目标`是`Makefile`的第一个`目标`，若想指定`总目标`则需要在执行`make`命令的时候指定`总目标`，如：`make 目标`。

   > 注意：`make`指令在寻找默认`总目标`的时候，找的是第一个不含通配符的目标，如：
   >
   > ```makefile
   > %.o:%c
   > 	gcc $^ -c -o $@
   > main:main.c
   > 	gcc %.o main.c -o main
   > ```
   >
   > 在上述`Makefile`中，`main目标`才是默认的`总目标`

3. 自动变量

   - `$@`：规则中的目标
   - `$<`：规则中的第一个依赖
   - `$^`：规则中的所有依赖

   > `目标+依赖+指令`作为一个整体称为规则，自动变量只能在规则中的指令中使用

4. 自定义变量

   1. 定义：`xxx=value`
   2. 使用：`$(xxx)`

5. 函数使用

   > `Makefile`中所有的函数都有返回值

   1. 使用并赋值：`变量 = $(函数名 参数1 参数2...)`

6. 伪目标

   1. 定义：根据`Makefile`的工作原理，若`目标`后面不跟`依赖`，且不在`任意目标`的`依赖`中，那么该`目标`则不会被执行，但可以使用`make 目标`命令执行指定`目标`的指令，这种`目标`可称为`伪目标`，主要做辅助作用

   2. 例子：

      ```makefile
      clean:
      	rm -f *.o
      ```

   3. 声明伪目标

      1. 说明：`目标`默认是目录下的文件，若使用`.PHONY`申明是伪目标，那么`make`则不会检测目录下是否存在文件，每次都会执行执行该规则

      2. 例子：

         ```makefile
         .PHONY:clean
         clean:
         	rm -f *.o
         ```

         

7. 错误抑制符

   1. 说明：执行命令的时候可能会报错，若命令报错则会阻止后续的命令继续执行，这时候可以添加错误抑制符`-`进行错误抑制

   2. 例子：

      ```makefile
      clean:
      	-rm -f *.o
      	echo "Hello world"
      ```

      